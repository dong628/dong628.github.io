<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>在 Archlinux 中使用 Zsh</title>
    <url>/2020/01/26/%E5%9C%A8%20Archlinux%20%E4%B8%AD%E4%BD%BF%E7%94%A8%20Zsh/</url>
    <content><![CDATA[<h2 id="什么是shell"><a class="markdownIt-Anchor" href="#什么是shell"></a> 什么是Shell</h2>
<p>shell是操作系统的命令解释器，在计算机科学中指“为用户提供用户界面”的软件，我的理解就是系统与用户沟通的桥梁。值得一提的是，shell不仅指的是命令行界面（CLI），图形界面（GUI）也是shell的一种。</p>
<a id="more"></a>
<blockquote>
<p>壳层（shell）这个说法起源于路易斯·普赞（Louis Pouzin），他在1964年至1965年间首次提出，随后在Multics（MULTiplexed Information and Computing System）项目中首次被实现出来。</p>
<p>Unix上的第一个Unix壳层（Unix shell）是肯·汤普逊（Ken Thompson）以Multics上的shell为范本，所写出的Thompson shell。</p>
<p>在微软的Windows操作系统也提供了命令行壳层的功能，它们是Windows 95 / <a href="http://xn--98command-1b6nt576a.com" target="_blank" rel="noopener">98下的command.com</a>、Windows NT内核下的cmd.exe以及PowerShell；而图形界面壳层即为explorer.exe。</p>
<p>——摘自维基百科：<a href="%5Bhttps://zh.wikipedia.org/wiki/%E6%AE%BC%E5%B1%A4%5D(https://zh.wikipedia.org/wiki/%E6%AE%BC%E5%B1%A4)">壳层</a></p>
</blockquote>
<p>在Linux的命令行界面中，可以有不同的shell，常见的有：bash，ksh，zsh 等，而其中的集大成制作当属 Zsh。它有更智能的自动补全和拼写检查，可以与其他的shell共享历史记录等特性。而插件 Oh My Zsh 使得它的入门门槛降低了许多。</p>
<p>可以使用<code>echo $SHELL</code> 命令来查看当前使用的shell。</p>
<h2 id="如何安装zsh"><a class="markdownIt-Anchor" href="#如何安装zsh"></a> 如何安装Zsh</h2>
<p>安装软件包<a href="https://www.archlinux.org/packages/extra/x86_64/zsh/" target="_blank" rel="noopener">zsh</a></p>
<p>，运行命令<code>zsh</code>，根据向导配置。</p>
<h3 id="将zsh作为你的默认终端"><a class="markdownIt-Anchor" href="#将zsh作为你的默认终端"></a> 将Zsh作为你的默认终端</h3>
<p>列出已安装的shell：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> chsh -l</span></span><br></pre></td></tr></table></figure>
<p>设置默认shell：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> chsh -s &lt;完整路径到shell&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="配置zsh"><a class="markdownIt-Anchor" href="#配置zsh"></a> 配置Zsh</h2>
<h3 id="oh-my-zsh"><a class="markdownIt-Anchor" href="#oh-my-zsh"></a> Oh My Zsh</h3>
<p>要想安装 Oh My Zsh ，运行以下命令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git clone git://github.com/robbyrussell/oh-my-zsh.git ~/.oh-my-zsh</span><br><span class="line">cp ~/.oh-my-zsh/templates/zshrc.zsh-template ~/.zshrc</span><br></pre></td></tr></table></figure>
<p>之后，重启电脑，就可以使用 Oh My Zsh 了</p>
<h3 id="zshrc"><a class="markdownIt-Anchor" href="#zshrc"></a> .zshrc</h3>
<p>.zshrc 文件是zsh的配置文件，位于home目录下，可以通过<code>ls -a</code>命令找到。可以在这个配置文件中设置别名和环境变量。比如我参考<a href="https://www.cnblogs.com/dhcn/p/11666845.html" target="_blank" rel="noopener">这篇文章</a>，配置成了这样：</p>
<p><img src="https://i.loli.net/2020/01/26/EY6O13uKBzkqMhb.png" alt="" /></p>
<p>在上面的<code>ZSH_THEME</code>选项中，可以更改主题，我使用的是agnoster，这个主题可以很方便地显示当前目录和git分支、仓库的情况等，所有的主题预览在<a href="https://github.com/ohmyzsh/ohmyzsh/wiki/External-themes" target="_blank" rel="noopener">这里</a>。</p>
<p><img src="agnoster" alt="https://cloud.githubusercontent.com/assets/2618447/6316862/70f58fb6-ba03-11e4-82c9-c083bf9a6574.png" /></p>
]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>「AcWing113」特殊排序</title>
    <url>/2020/07/12/%5BAcWing113%5D%E7%89%B9%E6%AE%8A%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<h1 id="关于题面"><a class="markdownIt-Anchor" href="#关于题面"></a> 关于题面</h1>
<p>题目链接：<a href="https://www.acwing.com/problem/content/115/" target="_blank" rel="noopener">https://www.acwing.com/problem/content/115/</a></p>
<p>有N个元素，编号1.2…N，每一对元素之间的大小关系是确定的，关系具有反对称性，但不具有传递性。</p>
<p><strong>注意</strong>：不存在两个元素大小相等的情况。</p>
<p>也就是说，元素的大小关系是N个点与N*(N-1)/2条有向边构成的任意有向图。</p>
<a id="more"></a>
<p>然而，这是一道交互式试题，这些关系不能一次性得知，你必须通过不超过10000次提问来获取信息，每次提问只能了解某两个元素之间的关系。</p>
<p>现在请你把这N个元素排成一行，使得每个元素都小于右边与它相邻的元素。</p>
<p>你可以通过我们预设的bool函数compare来获得两个元素之间的大小关系。</p>
<p>例如，编号为a和b的两个元素，如果元素a小于元素b,则compare（a,b）返回true，否则返回false。</p>
<p>将N个元素排好序后，把他们的编号以数组的形式输出，如果答案不唯一，则输出任意一个均可。</p>
<h3 id="数据范围"><a class="markdownIt-Anchor" href="#数据范围"></a> 数据范围</h3>
<p>1≤N≤1000</p>
<p>这题题面有些绕，我想了几分钟才理解。</p>
<p>大致意思是：系统那里有一个长度为N的数组，数组里的数据是无序的，下标为1、2、3、……N。你要为这个数组排序，但你并不知道里面这些数据，但你可以通过一个函数来问系统 数组内任意两个数的大小关系（通过编号），最后输出一个vector，里面存放数组<strong>值</strong>从小到大排序的编号顺序。</p>
<p>打个比方：</p>
<p>系统中这个数组是 {1, 6, 8, 3, 5}</p>
<p>那么，要返回的vector应该是 {1, 4, 5, 2, 3}</p>
<p>由于这是道交互题，样例非常让人摸不着头脑，所以并不是很好理解，但其实题目本身是非常简单的。</p>
<h1 id="基本思路"><a class="markdownIt-Anchor" href="#基本思路"></a> 基本思路</h1>
<p>既然只能知道某两个数的关系，那么快排那些交换数据的排序方法肯定是不能用了，可以考虑<strong>插入排序</strong>。</p>
<p>但是一般的插入排序如果要从数组开头一个个寻找插入点的话，时间复杂度是非常高的，由于要插入的那个数组是已经排好序的，可以使用二分法查找。</p>
<p>关于在vector中插入，vector类有以下的方法可以实现：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">v.insert(v.<span class="built_in">begin</span>()+n, a); 		<span class="comment">//表示在v数组中第n个元素前插入a</span></span><br></pre></td></tr></table></figure>
<h1 id="相似题目交互题"><a class="markdownIt-Anchor" href="#相似题目交互题"></a> 相似题目&amp;交互题</h1>
<p>洛谷上有一道题和这个非常像，也是二分法，也是交互题：<a href="https://www.luogu.com.cn/problem/P1947?contestId=29624" target="_blank" rel="noopener">https://www.luogu.com.cn/problem/P1947?contestId=29624</a></p>
<p>个人认为，交互题最大的难度在于没有办法测试，交互库不会公开，选手就无法得到数据，所以交互题对于选手的静态分析能力是一个很大的挑战。</p>
<h1 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h1>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Forward declaration of compare API.</span></span><br><span class="line"><span class="comment">// bool compare(int a, int b);</span></span><br><span class="line"><span class="comment">// return bool means whether a is less than b.</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">specialSort</span><span class="params">(<span class="keyword">int</span> N)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> len, l, r, mid;</span><br><span class="line">		<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; a;</span><br><span class="line">		a.insert(a.<span class="built_in">begin</span>(), <span class="number">1</span>); r++;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>; i&lt;=N; i++)&#123;</span><br><span class="line">			l=<span class="number">0</span>; r=i<span class="number">-1</span>;</span><br><span class="line">			<span class="keyword">while</span>(l&lt;r)&#123;</span><br><span class="line">				mid = (l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">				<span class="keyword">if</span>(compare(i, a[mid])) r = mid;</span><br><span class="line">				<span class="keyword">else</span> l = mid+<span class="number">1</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			a.insert(a.<span class="built_in">begin</span>()+l, i);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> a;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>「POJ2299」Ultra-QuickSort</title>
    <url>/2020/07/19/%E3%80%8CPOJ2299%E3%80%8DUltra-QuickSort/</url>
    <content><![CDATA[<h1 id="题目链接-题面"><a class="markdownIt-Anchor" href="#题目链接-题面"></a> 题目链接 &amp; 题面</h1>
<h2 id="题目链接"><a class="markdownIt-Anchor" href="#题目链接"></a> 题目链接</h2>
<p>UVA（洛谷有RemoteJudge）-<a href="https://onlinejudge.org/index.php?option=com_onlinejudge&amp;Itemid=8&amp;category=20&amp;page=show_problem&amp;problem=1751" target="_blank" rel="noopener">https://onlinejudge.org/index.php?option=com_onlinejudge&amp;Itemid=8&amp;category=20&amp;page=show_problem&amp;problem=1751</a></p>
<p>POJ-<a href="http://poj.org/problem?id=2299" target="_blank" rel="noopener">http://poj.org/problem?id=2299</a></p>
<p>AcWing-<a href="https://www.acwing.com/problem/content/109/" target="_blank" rel="noopener">https://www.acwing.com/problem/content/109/</a></p>
<p>（不知道哪个是原创，都写上吧。。）</p>
<a id="more"></a>
<h2 id="题目描述"><a class="markdownIt-Anchor" href="#题目描述"></a> 题目描述</h2>
<p>在这个问题中，您必须分析特定的排序算法----超快速排序。</p>
<p>该算法通过交换两个相邻的序列元素来处理n个不同整数的序列，直到序列按升序排序。</p>
<p>对于输入序列<code>9 1 0 5 4</code>，超快速排序生成输出<code>0 1 4 5 9</code>。</p>
<p>您的任务是确定超快速排序需要执行多少交换操作才能对给定的输入序列进行排序。</p>
<h3 id="输入格式"><a class="markdownIt-Anchor" href="#输入格式"></a> 输入格式</h3>
<p>输入包括一些测试用例。</p>
<p>每个测试用例的第一行输入整数<code>n</code>，代表该用例中输入序列的长度。</p>
<p>接下来<code>n</code>行每行输入一个整数<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>a</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">a_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>,代表用例中输入序列的具体数据，第i行的数据代表序列中第i个数。</p>
<p>当输入用例中包含的输入序列长度为0时，输入终止，该序列无需处理。</p>
<h3 id="输出格式"><a class="markdownIt-Anchor" href="#输出格式"></a> 输出格式</h3>
<p>对于每个需要处理的输入序列，输出一个整数<code>op</code>，代表对给定输入序列进行排序所需的最小交换操作数，每个整数占一行。</p>
<h3 id="数据范围"><a class="markdownIt-Anchor" href="#数据范围"></a> 数据范围</h3>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>0</mn><mo>≤</mo><mi>N</mi><mo>&lt;</mo><mn>5000000</mn><mo>≤</mo><mi>N</mi><mo>&lt;</mo><mn>500000</mn><mo separator="true">,</mo></mrow><annotation encoding="application/x-tex">0≤N&lt;5000000≤N&lt;500000,</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">0</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.72243em;vertical-align:-0.0391em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">5</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.72243em;vertical-align:-0.0391em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8388800000000001em;vertical-align:-0.19444em;"></span><span class="mord">5</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mpunct">,</span></span></span></span><br />
<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>0</mn><mo>≤</mo><msub><mi>a</mi><mi>i</mi></msub><mo>≤</mo><mn>999999999</mn></mrow><annotation encoding="application/x-tex">0≤a_i≤999999999</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">0</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.7859700000000001em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">9</span><span class="mord">9</span><span class="mord">9</span><span class="mord">9</span><span class="mord">9</span><span class="mord">9</span><span class="mord">9</span><span class="mord">9</span><span class="mord">9</span></span></span></span></p>
<h1 id="基本思路"><a class="markdownIt-Anchor" href="#基本思路"></a> 基本思路</h1>
<h2 id="逆序对"><a class="markdownIt-Anchor" href="#逆序对"></a> 逆序对</h2>
<p>对于数组<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi></mrow><annotation encoding="application/x-tex">a</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">a</span></span></span></span> ，当其下标<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span>，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>j</mi></mrow><annotation encoding="application/x-tex">j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span></span></span></span> 满足<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi><mo>&lt;</mo><mi>j</mi></mrow><annotation encoding="application/x-tex">i&lt;j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69862em;vertical-align:-0.0391em;"></span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span></span></span></span> 且<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>a</mi><mi>i</mi></msub><mo>&gt;</mo><msub><mi>a</mi><mi>j</mi></msub></mrow><annotation encoding="application/x-tex">a_i &gt; a_j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6891em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.716668em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span> 时，则称 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>a</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">a_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>a</mi><mi>j</mi></msub></mrow><annotation encoding="application/x-tex">a_j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.716668em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span> 构成逆序对。</p>
<p>例如序列<code>9 1 0 5 4</code>中，<code>9</code>和<code>1</code>是一对逆序对，<code>9</code>和<code>0</code>也是一对逆序对。</p>
<p>序列中，当逆序对的个数为0时，这个序列就是有序的，所以问题可以转化成“需要多少次交换可以将逆序对降为0”</p>
<p>交换两个相邻的逆序对时，序列的逆序对会减少<code>1</code>，这是因为，那两个相邻的数不再构成逆序对，并且它们和其它数的相对位置（不讨论距离）不变，和其它数构成的逆序对也不改变。</p>
<p>这样以来，只需要求出序列中逆序对的个数就可以知道需要交换几次。</p>
<h2 id="归并排序"><a class="markdownIt-Anchor" href="#归并排序"></a> 归并排序</h2>
<p>要求逆序对的个数，可以使用归并排序算法。</p>
<p>归并排序中，将一个序列拆成两半，并且左右两边排序之后，左半边任意一个数 和 右半边任意一个数 的相对位置并没有改变。</p>
<p>当左边的第 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span> 个数大于右边第 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>j</mi></mrow><annotation encoding="application/x-tex">j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span></span></span></span> 个数时，这两个数构成逆序对。</p>
<p>与此同时，左边的第 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">i+1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.74285em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> ，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi><mo>+</mo><mn>2</mn></mrow><annotation encoding="application/x-tex">i+2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.74285em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span></span></span></span> ……个数都大于 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>j</mi></mrow><annotation encoding="application/x-tex">j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span></span></span></span>， 可以一次性统计。</p>
<p>有关归并排序算法，可以去听小甲鱼老师的 数据结构和算法：<a href="https://www.bilibili.com/video/BV1os41117Fs?p=95" target="_blank" rel="noopener">https://www.bilibili.com/video/BV1os41117Fs?p=95</a></p>
<h1 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h1>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX 500005</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a[MAX], n;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> ans;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MergeSort</span><span class="params">(<span class="keyword">int</span>*, <span class="keyword">int</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//	freopen("data.in", "r", stdin);</span></span><br><span class="line">	<span class="keyword">for</span>( ; ; )&#123;</span><br><span class="line">		ans=<span class="number">0</span>;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">		<span class="keyword">if</span>(n==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;a[i]);</span><br><span class="line">		MergeSort(a, n);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, ans);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MergeSort</span><span class="params">(<span class="keyword">int</span> *arr, <span class="keyword">int</span> len)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(len==<span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> *l=arr, *r=arr+len/<span class="number">2</span>;</span><br><span class="line">	<span class="keyword">int</span> ls=len/<span class="number">2</span>, rs=len-len/<span class="number">2</span>;</span><br><span class="line">	MergeSort(l, ls);</span><br><span class="line">	MergeSort(r, rs);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> i=<span class="number">0</span>, j=<span class="number">0</span>, ts=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> temp[MAX];</span><br><span class="line">	<span class="keyword">while</span>(i&lt;ls &amp;&amp; j&lt;rs)&#123;</span><br><span class="line">		<span class="keyword">if</span>(l[i]&gt;r[j])&#123;</span><br><span class="line">			temp[ts++] = r[j++];</span><br><span class="line">			ans += ls-i;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> temp[ts++] = l[i++];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span>(j&lt;rs) temp[ts++] = r[j++];</span><br><span class="line">	<span class="keyword">while</span>(i&lt;ls) temp[ts++] = l[i++];</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> x=<span class="number">0</span>; x&lt;ts; x++)&#123;</span><br><span class="line">		arr[x] = temp[x];</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>算法</tag>
        <tag>题解</tag>
      </tags>
  </entry>
  <entry>
    <title>在 Archlinux 下上网课</title>
    <url>/2020/02/16/%E5%9C%A8Archlinux%E4%B8%8B%E4%B8%8A%E7%BD%91%E8%AF%BE/</url>
    <content><![CDATA[<p>最近，新型冠状病毒肺炎肆虐，学生们不得不延长假期，在家上网课。但有一个大问题：我们没有书。</p>
<p>于是，我们的老师给我们发了PDF格式的电子书，大概长这样：</p>
<a id="more"></a>
<p><img src="https://i.loli.net/2020/02/16/lZNujsFxLT7zRYD.png" alt="Screenshot_20200216_155502.png" /></p>
<p>我们当然可以把它打印出来，但那样浪费资源，关键是在这个谁都出不了门的时期，又有哪些人可以在家里打印这些资料呢？</p>
<p>于是我就想到，我们可以在电脑上看书和记笔记。而我正好有一块wacom的数位板，也可以在上面记笔记。</p>
<h2 id="钉钉"><a class="markdownIt-Anchor" href="#钉钉"></a> 钉钉</h2>
<p>由于钉钉并没有原生支持Linux，于是只能使用其它的办法。目前，如果想要在linux上运行windows程序，wine虽然已经很成熟了，但虚拟机更加稳定，而且可以适应几乎所以程序，于是我在vbox中创建了一个win10虚拟机，安装钉钉。这样就可以在虚拟机中上直播课了。</p>
<p>而且这么做还有一个好处：</p>
<p>众所周知，钉钉在直播开始时，都会告诉观看者：你的摄像头是全程关闭的。就像这样：</p>
<p><img src="https://i.loli.net/2020/02/16/uXnNK4aBte1Y32g.jpg" alt="Screenshot_20200216-160930_1_1.jpg" /></p>
<p>尽管如此，网上还是有人说老师可以调用学生的摄像头（尽管钉钉官方好像是辟谣了），并且在win10里，并不是所有的软件都可以在设置中关闭摄像头权限的，比如钉钉。</p>
<p>于是有些人使用物理屏蔽（堵摄像头啥的），而使用虚拟机就可以彻底杜绝它使用摄像头了。</p>
<h2 id="pdf"><a class="markdownIt-Anchor" href="#pdf"></a> PDF</h2>
<p>要想在PDF上记笔记，我们需要一款可以在PDF上批注的软件。</p>
<p>KDE自带的PDF工具 Okular 虽然右边有“批注”选项，但那个批注功能有和没有一样，点一次写一笔，完全不能用。</p>
<p>于是，只能自己找其他软件。</p>
<p>目前，可以批注并且兼容linux的PDF的阅读器，我找到了两款： MasterPDF editor 和 Foxit。</p>
<p>提起 Foxit ，相信很多人都不陌生，是windows下的老牌PDF阅读器，但在linux下，有一些文件的页面会被莫名拉长，而 MasterPDF editor 就并没有这个问题，但它是商业软件，免费版会在编辑后加上水印，但不是很重。只能说，鱼与熊掌不可兼得吧。</p>
<p>这两个软件，一个在<a href="https://aur.archlinux.org/packages/foxitreader/" target="_blank" rel="noopener">AUR源</a>里有，另一个在<a href="https://code-industry.net/free-pdf-editor/" target="_blank" rel="noopener">官网</a>可以下到linux版。</p>
<h2 id="wacom-和-屏幕"><a class="markdownIt-Anchor" href="#wacom-和-屏幕"></a> Wacom 和 屏幕</h2>
<p><a href="https://www.archlinux.org/packages/?name=xf86-input-wacom" target="_blank" rel="noopener">xf86-input-wacom</a>是wacom数位板在Arch下的驱动，使用<code>sudo pacman -S xf86-input-wacom</code>安装。</p>
<p>这样，就可以在arch下—愉快地—上网课了。</p>
<p>但我还有一块15寸的4k副屏，我可以将它竖起来看电子书：</p>
<p><img src="https://i.loli.net/2020/02/16/lUE1OZpKnjukzi5.jpg" alt="IMG_20200216_164757.jpg" /></p>
<p>那么怎样将这块屏幕和数位板利用上呢？</p>
<h3 id="屏幕映射"><a class="markdownIt-Anchor" href="#屏幕映射"></a> 屏幕映射</h3>
<p>在windows10下，如果你在多屏下使用数位版，windows会以 一个可以完整包含所有显示器显示范围的矩形 的四个定点，映射到数位板的上下左右四个点上。通俗地来说，windows10的wacom驱动无法将数位板映射到具体的某一块屏幕上。但是linux可以。</p>
<p>先是使用<code>xsetwacom --list devices</code> 查看数位板的id：</p>
<p><img src="https://i.loli.net/2020/02/16/lqbFYpdkHEsvhuf.png" alt="Screenshot_20200216_170418.png" /></p>
<p>此时，数位板（stylus）的id为23</p>
<p>如果你正常地配置好了显卡，使用命令 <code>xrandr</code> 找到你的那块屏幕：</p>
<p><img src="https://i.loli.net/2020/02/16/QHCAz1JRIsouBXn.png" alt="Screenshot_20200216_170859.png" /></p>
<p>比如我的外接屏幕是接在HDMI口上的，那么HDMI-0 就是我的屏幕，而后面的那一串形如“1080x1920+1920+0”是之后配置映射所用到的，确定你的屏幕的信息。</p>
<p>然后，使用<code>xsetwacom --set &lt;数位板id&gt; MapToOutput &quot;&lt;你的屏幕&gt;&quot;</code>使屏幕映射到数位板</p>
<h3 id="旋转数位板"><a class="markdownIt-Anchor" href="#旋转数位板"></a> 旋转数位板</h3>
<p>在windows10下，你无法将数位板竖起来使用，但在linux下，你可以将竖起来的数位板映射到一块竖着的屏幕上。</p>
<p>在映射配置好的情况下，使用<code>xsetwacom --set &lt;数位板id&gt; Rotate cw</code>用来顺时针旋转数位板。</p>
]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>［杂谈］一个故事的开始</title>
    <url>/2020/07/06/%EF%BC%BB%E6%9D%82%E8%B0%88%EF%BC%BD%E4%B8%80%E4%B8%AA%E6%95%85%E4%BA%8B%E7%9A%84%E5%BC%80%E5%A7%8B/</url>
    <content><![CDATA[<h2 id="这是一个结束的开始"><a class="markdownIt-Anchor" href="#这是一个结束的开始"></a> 这是一个结束的开始</h2>
<p>还有不到一年，初中生活就要结束了。还有不到一年，我们就要参加中考了。今天（2020年7月6日）早上，去学校参加了颁奖典礼。会上，老师多次和我们强调：我们的时间已经不多了。但学生代表pyt（好像是叫这个名字？）的发言中，详细计算了我们距离中考还有多少天，多少小时，多少分钟（尽管好像计算错了）……虽然我们即将面临的是一场至关重要的考试，但我们还有充足的时间准备。</p>
<a id="more"></a>
<p>这一学期开学以来，学习立马紧张了起来，各种考试接踵而来，学习的压力重重地压在了我们的头上。而当进入暑假，这场学习上的竞争正式开始了。上午的颁奖典礼中，有一个班级对抗赛颁奖的环节，一个年级16个班，8个班赢了，8个班输了（我们属于输的）。这些班的代表上台发表感言，并且输的班要给对方赠送礼物。在凤凰双语那10个班颁奖的过程中，现场充斥着一股“火药味”（高中部日常看淡成绩[捂脸]）。学习气氛似乎充满了整个学校。</p>
<p>11月，NOIP2020也要拉开帷幕，距离我上次大量刷题已经过去了进一年。去年我已经规划好，要在这个暑假继续大量刷题、写博客，对于我的算法学习而言，这也是一个至关重要的暑假。</p>
<p><img src="https://s1.ax1x.com/2020/07/06/UiHG2n.jpg" alt="UiHG2n.jpg" /></p>
<p>结束，指的是我们的初中生活即将结束。距离中考还有一年，我们的初中生活即将结束，同时，NOIP2020也将是我初中阶段的最后一场信息学奥赛。</p>
<p>开始，指的是我即将迈入的暑假，暑假结束后的两个学期，我们必将继续拼搏，而这个暑假是这个过程的开始。</p>
<h2 id="这是一个开始的结束"><a class="markdownIt-Anchor" href="#这是一个开始的结束"></a> 这是一个开始的结束</h2>
<p>这个暑假，我早就蓄谋已久。学期快要结束时，我就在思考这个暑假应该怎么过。在竞赛方面，去年我计划休息了一年，等到暑假冲击NOIP2020。近几年关于竞赛的政策飘忽不定，大约两个月前，大学自主招生被取消。这直接导致了许多竞赛生几年来的努力白费，对许多竞赛生的心态是一个巨大的打击。但当时我已经没有过多关注竞赛，反而对我的心态没有什么打击。暑假到了，冲击NOIP2020的时候也到了。暑假的开始，计划阶段 即将结束，这是一个开始的结束。</p>
<p>这个暑假，我主要学习的是《算法竞赛进阶指南》，从第一章开始，坚持每天刷题，有比较好（或者做了好长时间不过）的题，或者对我启发比较大的事，我会尽量以博客的形式总结。</p>
<p>对于文化课，我依然坚持不参加任何课外班。其实老师布置的任务已经够多了，认真完成作业，就足以在新的学期中跟紧老师们的步伐。</p>
<p><img src="https://s1.ax1x.com/2020/07/06/UiHACd.jpg" alt="UiHACd.jpg" /></p>
<p><img src="https://s1.ax1x.com/2020/07/06/UiHF4H.jpg" alt="UiHF4H.jpg" /></p>
<p><img src="https://s1.ax1x.com/2020/07/06/UiHiUe.jpg" alt="UiHiUe.jpg" /></p>
<p>同时，我会坚持体育锻炼，中考体育也是一个大项目，需要持之以恒的练习，待暑假结束，我将王者归来。</p>
<p>开始，指的是我对于暑假的计划，是暑假的开端。这个开端即将结束，我将要正式步入这个充实的暑假。</p>
]]></content>
      <tags>
        <tag>杂谈</tag>
      </tags>
  </entry>
  <entry>
    <title>浅谈Linux分区和挂载（点）</title>
    <url>/2020/01/04/%E6%B5%85%E8%B0%88Linux%E5%88%86%E5%8C%BA%E5%92%8C%E6%8C%82%E8%BD%BD%EF%BC%88%E7%82%B9%EF%BC%89/</url>
    <content><![CDATA[<h2 id="windows"><a class="markdownIt-Anchor" href="#windows"></a> Windows</h2>
<p>在windows下，分区是有明显的界限的，就比如这样：</p>
<p><img src="http://h.hiphotos.baidu.com/exp/w=500/sign=dee7d1b3a144ad342ebf8787e0a30c08/b58f8c5494eef01f75ed6b9be0fe9925bd317df6.jpg" alt="" /></p>
<p>在“此电脑”中的C盘、D盘、E盘等，都是分区。一般情况下，系统安装在C盘，其他分区一般用来存放资料，但是linux下的分区和windows不同。</p>
<a id="more"></a>
<h1 id="linux分区就是文件夹"><a class="markdownIt-Anchor" href="#linux分区就是文件夹"></a> Linux——分区就是文件夹</h1>
<p>其实这么说并不准确，因为Linux下“分区”的概念是比较模糊的。</p>
<p><img src="https://www.runoob.com/wp-content/uploads/2014/06/003vPl7Rty6E8kZRlAEdc690.jpg" alt=" " title="Linux下的目录树" /></p>
<p>Linux是以树的结构存储文件的。不管你的电脑中有几块硬盘（即便没有），也不管硬盘分了几个区，Linux都会给你整出来个根目录，也就是上图中最顶层的“/”。一旦你安装了Linux，它就会在根目录下创建几个文件夹，这些文件夹的名字是“root”、“home”、“dev”等等。路径分别是“/root”、“/home”、“/dev”等。</p>
<p>众所周知，存储文件需要硬盘。Linux这波操作光搞了个目录，但是与硬盘和分区没有任何关系，那么这些文件夹和之后要写入的文件存在哪里啊？这就引入了Linux下“挂载”的概念。</p>
<blockquote>
<p>分区就是个文件夹！</p>
</blockquote>
<p>在linux下，你可以像windows一样创建分区，但是并不像windows一样，创建完就给你显示在“此电脑”中（默认是这样的，也可以设置不显示）。但是在Linux下，要想使用一个分区，必须先要挂载。</p>
<p>前面说过，Linux下的根目录里是要存东西的，要想存东西，就要有硬盘。所以Linux的做法是：将根目录下的某一部分（也有可能是全部）与分区建立对应关系。</p>
<p>打个比方，打开你的文件管理器，在里面的地址栏中输入“/”，然后在空白区域右击，选择“属性”。</p>
<p><img src="https://i.loli.net/2020/01/04/9vsoRilzYA4uCHM.png" alt="Screenshot_20200104_154532.png" /></p>
<p>然后你应该可以看到挂载点和挂载的分区。其中，分区并不像Windows那样以盘符表示，而是一个文件。关于这个文件的意义，我们以后再说。</p>
<p><img src="https://i.loli.net/2020/01/04/hfXDUelGJ2LYqnb.png" alt="Screenshot_20200104_153959.png" /></p>
<p>而这个挂载点就是根目录“/”，也就是说，根目录下的所有文件，都存在了这个分区里？</p>
<p>其实并不是这样的，这个分区只是和根目录建立了一个对应关系，并不代表根目录中所有文件都存在了这个分区中。</p>
<p>再举个例子，插上你的U盘，如果你用的是KDE、GNOME这样的桌面环境，应该可以通过简单的动动鼠标，进入这个U盘。</p>
<p><img src="https://i.loli.net/2020/01/04/pSGx4mnEBcYgtlZ.png" alt="Screenshot_20200104_160153-1.png" /></p>
<p>而这时，点击文件管理器中的地址栏，你会得到一个路径，就像这样：</p>
<p><img src="https://i.loli.net/2020/01/04/a9JxvENR8B5yMCo.png" alt="Screenshot_20200104_160310.png" /></p>
<p>然后，在根目录下，按照这个目录，打开这个文件夹。</p>
<p>比如，我的是“/run/media/archer/7BD2-F1FA/”，于是我现在根目录下找到“run”文件夹，打开，再找到“media”文件夹，打开，在找到并打开“archer”文件夹（我的用户名），然后打开“7BD2-F1FA”文件夹。</p>
<p>然后，你就会发现：</p>
<blockquote>
<p>这不就是我U盘里的东西吗</p>
</blockquote>
<p><img src="https://i.loli.net/2020/01/04/3xwlDZvz4bB7H1P.png" alt="Screenshot_20200104_160941.png" /></p>
<p>在页面的空白处，右击，点击“属性”。“挂载点”那一栏写的就是你刚才打开的文件夹的路径，而“挂载自”一栏也是 /dev 目录下的一个文件，sd**代表这是一个分区。</p>
<p>这时，你可能就会发现：</p>
<blockquote>
<p>这个U盘（准确地说是这个分区）就是一个文件夹！！</p>
</blockquote>
<p>没错，分区本身，在Linux下是一个在 /dev 目录下的文件，你可以把它挂载到目录树的一个文件夹下，你才可以访问这个分区中的文件。</p>
<p>这个实验也表明了，Linux下的挂载点是可以嵌套的。你可以将任何一个分区挂载到任何一个目录（除了根目录必须作为一个挂载点挂载磁盘），这就为Linux的文件管理提供了无限的可能。比如说，我的Linux目录树是这样的：</p>
<p><img src="https://i.loli.net/2020/01/04/y7UbeZNcl3JxVwp.jpg" alt="003vPl7Rty6E8kZRlAEdc690_1.jpg" /></p>
<p>至于我为什么要把 /home 文件夹里的内容存到一个单独的分区里，这个以后再说。</p>
<h2 id="在linux下如何查看我的分区情况"><a class="markdownIt-Anchor" href="#在linux下如何查看我的分区情况"></a> 在Linux下如何查看我的分区情况</h2>
<p>Linux下，有一个分区工具叫做 fdisk ，你可以以root用户运行以下命令查看分区情况：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># fdisk -l</span><br></pre></td></tr></table></figure>
<p>就像这样：</p>
<p><img src="https://i.loli.net/2020/01/04/LByAR2Nagv9JrxH.png" alt="Screenshot_20200104_163440-1.png" /></p>
<p>其中&quot;nvme&quot;开头的是NVMe协议的硬盘（一般是固态），而sd开头的是通过SATA、SCSI、USB这些接口传输数据的存储设备，loop开头一般是光盘。</p>
]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>「题解」HNOI2003 激光炸弹</title>
    <url>/2020/07/07/%EF%BC%BB%E9%A2%98%E8%A7%A3%EF%BC%BDHNOI2003%20%E6%BF%80%E5%85%89%E7%82%B8%E5%BC%B9/</url>
    <content><![CDATA[<h2 id="基本思路"><a class="markdownIt-Anchor" href="#基本思路"></a> 基本思路</h2>
<p>基本的二维前缀和，把从（0,0）到任何一个点围成的矩形中所有的价值计算出来，然后再通过容斥原理算出所有可能正方形中的价值之和。</p>
<p>如果把初始的地图存入A数组，那么它的二位前缀和S就是：</p>
<p>$S[i][j]=\sum_{x=1}^{i} \sum_{y=1}^{j} A[x][y] $</p>
<p>根据容斥原理，有：</p>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>S</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>j</mi><mo stretchy="false">]</mo><mo>=</mo><mi>s</mi><mo stretchy="false">[</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>j</mi><mo stretchy="false">]</mo><mo>+</mo><mi>s</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>j</mi><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo><mo>+</mo><mi>A</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>j</mi><mo stretchy="false">]</mo><mo>−</mo><mi>S</mi><mo stretchy="false">[</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>j</mi><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">S[i][j] = s[i-1][j]+s[i][j-1]+A[i][j]-S[i-1][j-1]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">s</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">s</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">A</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span></span></span></span></p>
<p>这样，就可以利用上述递推式推出S数组。</p>
<a id="more"></a>
<p>同时，对于任意一个边长为R，最靠近原点的顶点为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">(</mo><mi>x</mi><mo separator="true">,</mo><mi>y</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(x, y)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mclose">)</span></span></span></span>的正方形，其内部所有点的价值之和为：</p>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>S</mi><mo stretchy="false">[</mo><mi>x</mi><mo>+</mo><mi>R</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>y</mi><mo>+</mo><mi>R</mi><mo stretchy="false">]</mo><mo>−</mo><mi>S</mi><mo stretchy="false">[</mo><mi>x</mi><mo>+</mo><mi>R</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>y</mi><mo stretchy="false">]</mo><mo>−</mo><mi>S</mi><mo stretchy="false">[</mo><mi>x</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>y</mi><mo>+</mo><mi>R</mi><mo stretchy="false">]</mo><mo>+</mo><mi>S</mi><mo stretchy="false">[</mo><mi>x</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>y</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">S[x+R][y+R]-S[x+R][y]-S[x][y+R]+S[x][y]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mopen">[</span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mopen">[</span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mopen">[</span><span class="mord mathdefault">x</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mopen">[</span><span class="mord mathdefault">x</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mclose">]</span></span></span></span></p>
<p>这样，就可以以<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>的时间复杂度解题。</p>
<h2 id="我踩过的坑"><a class="markdownIt-Anchor" href="#我踩过的坑"></a> 我踩过的坑</h2>
<ol>
<li>
<p>这题有125MB的空间限制，根据上述递推式，只需要一个数组就可以完成，开两个范围为5000的二位数组貌似过不了。。</p>
</li>
<li>
<p>数据规模约定中，n最大可以到<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn><msup><mn>0</mn><mn>4</mn></msup></mrow><annotation encoding="application/x-tex">10^4</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">4</span></span></span></span></span></span></span></span></span></span></span>，然而并没有那么大的地图，相当于“全图轰炸”，此时效果与<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mo>=</mo><mn>5</mn><mo>∗</mo><mn>1</mn><msup><mn>0</mn><mn>3</mn></msup></mrow><annotation encoding="application/x-tex">n=5*10^3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">5</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span></span></span></span></span></span></span></span>效果相同，可以直接替换。数组开到<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn><msup><mn>0</mn><mn>4</mn></msup></mrow><annotation encoding="application/x-tex">10^4</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">4</span></span></span></span></span></span></span></span></span></span></span>的话会爆空间的。</p>
</li>
<li>
<p>数组稍微开大一点点。</p>
</li>
<li>
<p>最重要的一点，数据要从<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">(</mo><mn>1</mn><mo separator="true">,</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(1,1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mclose">)</span></span></span></span>开始存，也就是说，边界应该为0,这样才能保证边界的数可以被正确计算</p>
</li>
</ol>
<p>我一开始没有注意第3点，之后在洛谷得了90分，被这样一个数据卡住了：</p>
<p><img src="https://s1.ax1x.com/2020/07/07/UFjZ6J.jpg" alt="UFjZ6J.jpg" /></p>
<p>可以看到，全是第0列的点。。</p>
<p>之后自己造了一个数据，成功发现了这个问题：</p>
<p><img src="https://s1.ax1x.com/2020/07/07/UFjR7q.jpg" alt="UFjR7q.jpg" /></p>
<h2 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h2>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX=<span class="number">5002</span>;</span><br><span class="line"><span class="keyword">int</span> s[MAX+<span class="number">5</span>][MAX+<span class="number">5</span>], n, r, summ, maxx, x, y, w;</span><br><span class="line"><span class="keyword">int</span> xmax, ymax;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//	freopen("data.in", "r", stdin);</span></span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d %d"</span>, &amp;n, &amp;r);</span><br><span class="line">	<span class="keyword">if</span>(r&gt;<span class="number">5000</span>) r=<span class="number">5000</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i++)&#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d %d %d"</span>, &amp;x, &amp;y, &amp;w);</span><br><span class="line"><span class="comment">//		xmax = xmax&gt;x?xmax:x;</span></span><br><span class="line"><span class="comment">//		ymax = ymax&gt;y?ymax:y;</span></span><br><span class="line">		s[x+<span class="number">1</span>][y+<span class="number">1</span>] += w;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="comment">/*	for(int i=1; i&lt;=MAX+2; i++)&#123;</span></span><br><span class="line"><span class="comment">		s[i][0] += s[i-1][0];</span></span><br><span class="line"><span class="comment">	&#125;</span></span><br><span class="line"><span class="comment">	for(int i=1; i&lt;=MAX+2; i++)&#123;</span></span><br><span class="line"><span class="comment">		s[0][i] += s[0][i-1];</span></span><br><span class="line"><span class="comment">	&#125;*/</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=MAX+<span class="number">2</span>; i++)&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>; j&lt;=MAX+<span class="number">2</span>; j++)&#123;</span><br><span class="line">			s[i][j] += s[i<span class="number">-1</span>][j]+s[i][j<span class="number">-1</span>]-s[i<span class="number">-1</span>][j<span class="number">-1</span>];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;=MAX-r; i++)&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;=MAX-r; j++)&#123;</span><br><span class="line">			summ = s[i+r][j+r]-s[i+r][j]-s[i][j+r]+s[i][j];</span><br><span class="line">			maxx = maxx&gt;summ?maxx:summ;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	maxx = maxx&gt;s[r][r]?maxx:s[r][r];</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%d"</span>, maxx);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>［杂谈］一个故事的结束</title>
    <url>/2020/07/05/%EF%BC%BB%E6%9D%82%E8%B0%88%EF%BC%BD%E4%B8%80%E4%B8%AA%E6%95%85%E4%BA%8B%E7%9A%84%E7%BB%93%E6%9D%9F/</url>
    <content><![CDATA[<p>７月２日，期末考试的尘埃落定又标志这我一个学期的结束。看到朋友圈里许多同学都写下了自己对这个学期的总结，于是我也来趁着这个初二年级的结束来对我之前的学习做个总结（原谅我文笔不太好。。）。我上次写总结已经是2019年的暑假结束了，那么这次就写一些从那时到现在我的一系列故事吧。</p>
<p>回想起这个学期，大部分时间都在网课中度过，开学之后就是各种考试。但直到学校给我们施加上前所未有的压力后，我才意识到，一年后的我们，就要接受义务教育阶段最重要的考试——中考 了。过去的几个学期中，我在八年级时的变化是最大的。</p>
<a id="more"></a>
<p>这是一次对自我的更深刻的认知。八年级的我接触到了更广阔的世界，了解到了更多的人。从2019年9月开始，我几乎没有再学习新的算法，我在算法竞赛上几乎毫无进展。这一方面是因为开学后的时间变少，另一方面是因为我在逐渐调整对自我的认知。</p>
<p><img src="https://i.loli.net/2020/07/05/2bQapdrKRICD4jm.jpg" alt="Screenshot_20200705_101620.jpg" /></p>
<h2 id="八月底的决定"><a class="markdownIt-Anchor" href="#八月底的决定"></a> 八月底的决定</h2>
<p>以下内容连接我的暑假总结（<a href="https://www.luogu.com.cn/blog/tfls-djl/post-shu-jia-zong-jie-yi-ge-guan-yu-jian-chi-di-gu-shi%EF%BC%89%EF%BC%8C%E8%AF%B7%E7%BB%93%E5%90%88%E9%A3%9F%E7%94%A8%E3%80%82" target="_blank" rel="noopener">https://www.luogu.com.cn/blog/tfls-djl/post-shu-jia-zong-jie-yi-ge-guan-yu-jian-chi-di-gu-shi），请结合食用。</a></p>
<p>去年的暑假，我坚持每天更新一篇博客，也刷了非常多的题，其中大部分是关于搜索的。在这期间，我参加了一些学校组织的比赛。我当时只学了不到一年的竞赛，只有普及组省二的水平，连动态规划都不会。。但令我吃惊的是，这些比赛我都取得了比较好的成绩，比许多学得时间比我长，算法储备也比我丰富的多的初三、高一的同学排名都要靠前。我认为这是因为我在其他许多方面的知识储备占了优势，而且我还有许多时间来学竞赛（其实SX这么弱，高中开始学确实不晚。。），于是我作出了一个影响深远的决定：放慢学习算法竞赛的速度。</p>
<h2 id="新的领域"><a class="markdownIt-Anchor" href="#新的领域"></a> 新的领域</h2>
<p>9月我接触到了ArchLinux，便疯狂沉迷其中。这是一个相当难以驾驭的GNU/Linux发行版，是进阶的必经之路（当然我主要是觉得它挺有意思的）。<s>于是我就装一个系统装了半年。。</s></p>
<p>这是一个相当复杂的工程。虽然官方有详细的wiki和教程，但每台电脑的具体情况是不同的，不可能把所有机型都考虑到。再加上我对Linux的认识只有用了不到一年的Ubuntu，于是在这条路上困难重重。在虚拟机上完全没有问题的系统撞到实体机上就会出问题，还几次把我的引导分区搞坏，导致电脑无法正常启动……我完全低估了这个新的领域的难度……于是，在八年级上半学期，我大部分空闲时间都在折腾Linux。</p>
<p><img src="https://i.loli.net/2020/07/05/BMYdKuPUvci2yz8.jpg" alt="Screenshot_20200705-173106.jpg" /></p>
<p>由于在其它领域花费时间过多，还有各种各样的环境问题，我对算法竞赛的学习在一个学期里停滞不前……而11月，我就要参加CSP2019了，这是信息学奥赛中最重要的比赛。比赛分为普及组和提高组、18年我已经参加过NOIP（CSP的前身）普及组了，19年我想要参加提高组。但教练觉得我的水平不够，想让我拿到一等奖后再参加提高（18年我拿了二等奖）。。于是我又陷入了无限的反思中……最后，我同意去参加普及组，但当时为时已晚，没有办法再改了~~（然后我就有拿了个省二）~~……</p>
<p>这几件事为什么我要一起说呢。。因为它们造成了我心态的一次大的改变……我感受到了前所未有的**“孤独”**</p>
<p>Linux在中国是一个很小的圈子，没有多少人会因为兴趣而折腾这些没什么用的东西……这就导致我遇到的大部分问题都不知道该怎么解决…之前学算法竞赛时，如果遇到哪些题不会，百度一下就会找到题解，如果学校有竞赛队的话，还可以去问老师同学。但我并没有找见许多在系统上和我遇到同样问题的人，我的兴趣也在系统的一次次error中消磨……我多次想要放弃，但最后还是坚持了下来。算法方面，几个月的毫无进展对我的心态无疑是一个巨大的打击。遇到问题就会变得非常着急，心态不好又会导致更多的问题……我似乎陷入了这个恶性循环中……</p>
<p>那么这些看起来这么负面的东西有带给我了什么启发呢？</p>
<p>首先是英语水平的巨大提升。那段时间，我上Google和查英文wiki的时间大幅增加，这导致我英语的阅读量有了飞跃。当我真正用到这些东西的时候，应试就不是什么困难的事了，于是在八上期末考试中，我拿到了英语单科的年级第一。</p>
<p>其次是心态的变化，也带给了我许多感悟。我承受许多打击的能力变强（因为我在这期间遭受了太多打击。。），对待很多事情也变得非常“佛系”。我意识到，不管是文化课还是竞赛还是其他奇怪的知识的学习中，心态是至关重要的，心态不好就会陷入恶性循环中。</p>
<p>最后是对Linux系统的认识有了质的飞跃。GNU/Linux系统中处处充满着“自由”，可以自由地修改源代码再分发，可以自由地修改系统中的任何配置，甚至可以随意“破坏”系统中的任何事物。正如那句名言：</p>
<blockquote>
<p>Unix（Linux的父分支）的目的并不是阻止用户做傻事，因为那样也会阻止他们做聪明的事。	——Doug Gwyn</p>
</blockquote>
<p><img src="https://i.loli.net/2020/07/05/H54MJvipG9Bmetr.jpg" alt="Screenshot_20200705-173210_1.jpg" /></p>
<p>这样的情况一直持续到了寒假结束，直到新学期我才真正走出这个阶段。</p>
<h2 id="前所未有的压力"><a class="markdownIt-Anchor" href="#前所未有的压力"></a> 前所未有的压力</h2>
<p>受疫情影响，我们被迫在家上了三个月的网课。在这期间我重装了系统，并且每天运行“sudo pacman -Syu”（更新系统的命令），稳定运行到现在（7月5日）。虽然没有了每天和老师的见面，但钉钉动听的提示音还是能让我整天提心吊胆。进入新学期，我们的压力明显增大，每天的网课和作业让我对这一点有了深刻体会——即便是网课，也要比上个学期紧张。</p>
<p><img src="https://i.loli.net/2020/07/05/Dua3F5CHloRmWMg.jpg" alt="Screenshot_20200705-220834_1.jpg" /></p>
<p>而在开学后，我才发觉——网课真是太轻松了。。每周上六节课，每天的最后一节自习课考试，几乎没有了自习课看闲书的时间。班里一共52个人，有大约40个人参加了晚自习，每天9点才能下课，作业经常写到10点半。学校对手机有了严格的管控，建议我们每个人把手机上交年级组，以督促我们学习。前所未有的压力，压在了我们每个人的头上。这时，我才猛地意识到：我们还有一年就要中考了。</p>
<h2 id="结束了"><a class="markdownIt-Anchor" href="#结束了"></a> 结束了？</h2>
<p><img src="https://i.loli.net/2020/07/05/N6YzG3CQHtmS7Oq.jpg" alt="游戏Minecraft中的进度“结束了？”" /></p>
<p>升入初二年级后，我发生了巨大的变化。将近一年过去了，我的这个充满着思考、无奈、彷徨、收获的故事也是时候该结束了。接下来的暑假，将会是又一个崭新的故事……</p>
<p>敬请期待……</p>
]]></content>
      <tags>
        <tag>杂谈</tag>
      </tags>
  </entry>
  <entry>
    <title>「NOI Online 提高组 」T3 最小环 70分题解</title>
    <url>/2020/03/13/%E6%9C%80%E5%B0%8F%E7%8E%AF70%E5%88%86%E9%A2%98%E8%A7%A3/</url>
    <content><![CDATA[<p><a href="https://www.luogu.cok.cn/problek/P6187" target="_blank" rel="noopener">题目链接</a></p>
<p><img src="https://i.loli.net/2020/03/09/kp7TWLjf61FaYvt.jpg" alt="c67625086b63f624199efc639044ebf81b4ca37e.jpg" /></p>
<p>这篇文章中， “基本思路”部分会详细介绍我最真实的推理过程，可能会有些啰嗦，还会包括一些显而易见随手推一推就能推出来的结论的证明，这些结论我已经用粗体字标注出来了。</p>
<a id="more"></a>
<h2 id="基本思路"><a class="markdownIt-Anchor" href="#基本思路"></a> 基本思路</h2>
<p>观察样例，<s>显然</s>：</p>
<p><strong>当n可以被k整除时，整个环可以拆分成k个互不相关的环。</strong></p>
<p>样例中，k=2时，可以将最优方案看成<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>3</mn><mo separator="true">,</mo><mn>1</mn><mo separator="true">,</mo><mn>2</mn></mrow><annotation encoding="application/x-tex">{3,1,2}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8388800000000001em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord">3</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">2</span></span></span></span></span>和<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>6</mn><mo separator="true">,</mo><mn>4</mn><mo separator="true">,</mo><mn>5</mn></mrow><annotation encoding="application/x-tex">{6,4,5}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8388800000000001em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord">6</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">4</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">5</span></span></span></span></span>两个集合中任意两个距离为1的数的乘积的和。</p>
<p>当一个环中只有三个数，并且k=1（也就是要求相邻两个数乘积的和）时，三个数的位置并不会影响最终结果，因为每个数都会和另外两个数分别乘一次。<strong>所以把三个最小的数 和三个最大的数 组合在一起，就是最优解。</strong></p>
<p>这个结论比较容易想到，以下是证明过程：</p>
<h3 id="n6k3-时的证明"><a class="markdownIt-Anchor" href="#n6k3-时的证明"></a> n=6，k=3 时的证明</h3>
<p>尝试把两个集合中的任意一个数互换位置。比如互换1和6，那么两个集合就会变成<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>3</mn><mo separator="true">,</mo><mn>6</mn><mo separator="true">,</mo><mn>2</mn></mrow><annotation encoding="application/x-tex">{3, 6, 2}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8388800000000001em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord">3</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">6</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">2</span></span></span></span></span>和<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn><mo separator="true">,</mo><mn>4</mn><mo separator="true">,</mo><mn>5</mn></mrow><annotation encoding="application/x-tex">{1, 4, 5}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8388800000000001em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">4</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">5</span></span></span></span></span>，比较第一个集合算出的结果在这次交换后上升的值 和 第二个集合（算出的结果）在交换后下降的值，它们分别为<span class='katex-error' title='ParseError: KaTeX parse error: Undefined control sequence: \* at position 6: (6-1)\̲*̲(3+2)'>(6-1)\*(3+2)</span>和<span class='katex-error' title='ParseError: KaTeX parse error: Undefined control sequence: \* at position 6: (6-1)\̲*̲(4+5)'>(6-1)\*(4+5)</span>，不论交换哪两个数，两个式子第一个乘数都相等。而第二个乘数中，第二个集合总比第一个集合大。综上所述，第一个集合上升的值比第二个集合下降的值要小，它们的和会下降。</p>
<p>而我们很容易把这个证明推广到正整数范围。</p>
<h3 id="那么当n不能被k整除时呢"><a class="markdownIt-Anchor" href="#那么当n不能被k整除时呢"></a> 那么当n不能被k整除时呢？</h3>
<p>先说结论：<strong>当k不能整除n时，只要n不变，最大值就确定</strong></p>
<h4 id="理论"><a class="markdownIt-Anchor" href="#理论"></a> 理论</h4>
<p>还是举个例子：</p>
<p>比如n=7, k=3时，这个环为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn><mo separator="true">,</mo><mn>2</mn><mo separator="true">,</mo><mn>3</mn><mo separator="true">,</mo><mn>4</mn><mo separator="true">,</mo><mn>5</mn><mo separator="true">,</mo><mn>6</mn><mo separator="true">,</mo><mn>7</mn></mrow><annotation encoding="application/x-tex">{1, 2, 3, 4, 5, 6, 7}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8388800000000001em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">2</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">3</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">4</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">5</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">6</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">7</span></span></span></span></span>时，算出的和为：</p>
<p>$1<em>4+4</em>7+7<em>3+3</em>6+6<em>2+2</em>5+5*1$</p>
<p>显然（其实我也不知道是为什么），没有重复和遗漏，并且按照这个顺序，<strong>我们也可以把它看成7个数的环中，相邻的两个数乘积的和</strong>，只不过是这个“相邻”指的是距离为k的两个数。</p>
<p>和传统意义上的“相邻”（即k=1）一样，这个环上的每个数<strong>有且仅有</strong>两个数和它相乘。对于这道题，唯一的不同点在于，对于同样的一个环，k会影响其最后算出的和。但是对于本题中求的最大值，我们可以在算出k=1（因为这比较方便计算）后再去调整“相邻”</p>
<h4 id="例子如何变换"><a class="markdownIt-Anchor" href="#例子如何变换"></a> 例子：如何变换</h4>
<p>比如n=7，k=1时，这个环是这样的：</p>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn><mo separator="true">,</mo><mn>2</mn><mo separator="true">,</mo><mn>3</mn><mo separator="true">,</mo><mn>4</mn><mo separator="true">,</mo><mn>5</mn><mo separator="true">,</mo><mn>6</mn><mo separator="true">,</mo><mn>7</mn></mrow><annotation encoding="application/x-tex">{1, 2, 3, 4, 5, 6, 7}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8388800000000001em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">2</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">3</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">4</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">5</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">6</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">7</span></span></span></span></span></p>
<p>算出的和为：</p>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn><mo>∗</mo><mn>2</mn><mo>+</mo><mn>2</mn><mo>∗</mo><mn>3</mn><mo>+</mo><mn>3</mn><mo>∗</mo><mn>4</mn><mo>+</mo><mn>4</mn><mo>∗</mo><mn>5</mn><mo>+</mo><mn>5</mn><mo>∗</mo><mn>6</mn><mo>+</mo><mn>6</mn><mo>∗</mo><mn>7</mn><mo>+</mo><mn>7</mn><mo>∗</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">1*2+2*3+3*4+4*5+5*6+6*7+7*1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">3</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">3</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">4</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">4</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">5</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">5</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">6</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">6</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">7</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">7</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span></p>
<p>当k=3时，如何变换这个环，使算出来的值等于k=1是的值呢？（以下步骤使用x表示未知数）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 首先，将1（第1个数，后同理）填入任何一个位置（因为是一个环，首尾相接，绝对未知并不会影响最终结果。为方便演示，填到[0]的位置）</span><br><span class="line"></span><br><span class="line">&#123;1, x, x, x, x, x, x&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 找到与1相邻的位置，填2</span><br><span class="line"></span><br><span class="line">&#123;1, x, x, 2, x, x, x&#125; 或 &#123;1, x, x, x, 2, x, x&#125;  &#x2F;&#x2F;两种分别对应往前数和往后数，后省略，以第一种为例</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 找到另一个与2相邻的位置（即两个位置中未知的那个），填3</span><br><span class="line"></span><br><span class="line">&#123;1, x, x, 2, x, x, 3&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 以此类推，找到另一个与n相邻的未知，填(n+1)</span><br><span class="line"></span><br><span class="line">&#123;1, x, 4, 2, x, x, 3&#125;</span><br><span class="line">&#123;1, x, 4, 2, x, 5, 3&#125;</span><br><span class="line">&#123;1, 6, 4, 2, x, 5, 3&#125;</span><br><span class="line">&#123;1, 6, 4, 2, 7, 5, 3&#125;</span><br></pre></td></tr></table></figure>
<p>相信在这个过程中，可以生动体会到上面的理论</p>
<p>于是，将这个环代入计算，过程和结果与上面的完全一致。</p>
<h3 id="找出最大值"><a class="markdownIt-Anchor" href="#找出最大值"></a> 找出最大值</h3>
<p>上面说了那么多，总结起来一句话：<strong>当n与环a一定，且k不整除n时，最大值不随k变化而变化（k这时可以当作1）</strong></p>
<p>而当k整除n时，又可以拆成k个小环，而每个子环都可以看成是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mo>=</mo><mo stretchy="false">(</mo><mi>n</mi><mi mathvariant="normal">/</mi><mi>k</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">n=(n/k)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mord">/</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mclose">)</span></span></span></span>，$ k=1$的环。</p>
<p>这样，我们就把两种情况统一成一种了。</p>
<p>唯一例外的是，当k为一个完全平方数，且sqrt(k)整除n时，可以看作是k=sqrt(k)</p>
<p>现在要实现的就是，当k=1时，怎样排列可以使这个值最大。</p>
<h4 id="实例"><a class="markdownIt-Anchor" href="#实例"></a> 实例</h4>
<p>可以参考样例中k=1, n=6时的排列：</p>
<p>可以发现和6相邻的为4和5，和5相邻的另一个数是3，和4相邻的另一个数是2。</p>
<p>这样排列把最大的数放在了一起，然后从大到小排列，尽可能把大的数放在一起。我会用n=7, k=1来演示这个过程</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;x, x, x, x, x, x, x&#125; &#x2F;&#x2F;初始状态</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 在任意位置放7,并且时6,5与7相邻</span><br><span class="line"></span><br><span class="line">&#123;x, x, 5, 7, 6, x, x&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 在6旁边放剩余的最大的数</span><br><span class="line"></span><br><span class="line">&#123;x, x, 5, 7, 6, 4, x&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 在5旁边放剩余最大的数</span><br><span class="line"></span><br><span class="line">&#123;x, 3, 5, 7, 6, 4, x&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 重复这一过程，每次将 相邻位置有空位的最大数 的 另一个位置填上剩余最大数</span><br><span class="line"></span><br><span class="line">&#123;x, 3, 5, 7, 6, 4, 2&#125;</span><br><span class="line">&#123;1, 3, 5, 7, 6, 4, 2&#125;</span><br></pre></td></tr></table></figure>
<p>这种方法貌似时有一种贪心思想在内，要想证明这种方法有效， 可以用类似上面的证明方法，这里不再赘述。</p>
<h4 id="实际应用与代码"><a class="markdownIt-Anchor" href="#实际应用与代码"></a> 实际应用与代码</h4>
<p>在多举几个例子后，会发现，在代码中，并不需要使用一个数组来真正存储它，只需要实现这样一个函数：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> <span class="title">ch</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> l)</span></span>&#123;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> aa=<span class="number">0</span>;</span><br><span class="line">	aa+=a[z]*a[z+<span class="number">1</span>];</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;l<span class="number">-2</span>; i++)&#123;</span><br><span class="line">		aa+=a[z]*a[z+<span class="number">2</span>];</span><br><span class="line">		z++;</span><br><span class="line">	&#125;</span><br><span class="line">	aa+=a[z]*a[z+<span class="number">1</span>];</span><br><span class="line">	z+=<span class="number">2</span>;</span><br><span class="line">	<span class="keyword">return</span> aa;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>基本原理就是上面的一大堆，自己稍微推一下就会得出这个算法。</p>
<h2 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h2>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> len=<span class="number">2</span>*<span class="number">1e5</span>+<span class="number">5</span>;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> n, m, k, z, re;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ans, a[len];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123; <span class="keyword">return</span> a&gt;b; &#125;</span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> <span class="title">ch</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> l)</span></span>&#123;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> aa=<span class="number">0</span>;</span><br><span class="line">	aa+=a[z]*a[z+<span class="number">1</span>];</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;l<span class="number">-2</span>; i++)&#123;</span><br><span class="line">		aa+=a[z]*a[z+<span class="number">2</span>];</span><br><span class="line">		z++;</span><br><span class="line">	&#125;</span><br><span class="line">	aa+=a[z]*a[z+<span class="number">1</span>];</span><br><span class="line">	z+=<span class="number">2</span>;</span><br><span class="line">	<span class="keyword">return</span> aa;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	freopen(<span class="string">"ring.in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line">	freopen(<span class="string">"ring.out"</span>, <span class="string">"w"</span>, <span class="built_in">stdout</span>);</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%lld %lld"</span>, &amp;n, &amp;m);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i++)&#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%lld"</span>, &amp;a[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	sort(a, a+n, cmp);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;m; i++)&#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%lld"</span>, &amp;k);</span><br><span class="line">		ans=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">if</span>((k!=<span class="number">0</span>) &amp;&amp; ((n/k)*k!=n) &amp;&amp; (<span class="keyword">int</span>(<span class="built_in">sqrt</span>(k))*<span class="keyword">int</span>(<span class="built_in">sqrt</span>(k))==k)) k=<span class="keyword">int</span>(<span class="built_in">sqrt</span>(k));</span><br><span class="line">		<span class="keyword">if</span>(k==<span class="number">0</span>)&#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;n; j++) ans+=a[j]*a[j];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>((n/k)*k==n)&#123;</span><br><span class="line">			z=<span class="number">0</span>;</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;k; j++)&#123;</span><br><span class="line">				ans+=ch(n/k);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"><span class="comment">//		else if((n/sqrt(k))*sqrt(k)==n)&#123;</span></span><br><span class="line"><span class="comment">//			k=sqrt(k);</span></span><br><span class="line"><span class="comment">//			z=0;</span></span><br><span class="line"><span class="comment">//			for(int j=0; j&lt;k; j++)&#123;</span></span><br><span class="line"><span class="comment">//				ans+=ch(n/k);</span></span><br><span class="line"><span class="comment">//			&#125;</span></span><br><span class="line"><span class="comment">//		&#125;</span></span><br><span class="line">		<span class="keyword">else</span>&#123;</span><br><span class="line">			<span class="keyword">if</span>(re&gt;<span class="number">0</span>) ans=re;</span><br><span class="line">			<span class="keyword">else</span>&#123;</span><br><span class="line">				z=<span class="number">0</span>;</span><br><span class="line">				ans=ch(n);</span><br><span class="line">				re=ans;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, ans);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>「CH0601」Genius ACM</title>
    <url>/2020/07/26/%E3%80%8CCH0601%E3%80%8DGenius%20ACM/</url>
    <content><![CDATA[<h1 id="题目链接-题面"><a class="markdownIt-Anchor" href="#题目链接-题面"></a> 题目链接 &amp; 题面</h1>
<p>AcWing：<a href="https://www.acwing.com/problem/content/description/111/" target="_blank" rel="noopener">https://www.acwing.com/problem/content/description/111/</a></p>
<p>ContestHunter 挂了，只有 AcWing 上能找到这题了。。</p>
<h2 id="题目描述"><a class="markdownIt-Anchor" href="#题目描述"></a> 题目描述</h2>
<p>给定一个整数 M，对于任意一个整数集合 S，定义“校验值”如下:</p>
<p>从集合 S 中取出 M 对数(即 2∗M个数，不能重复使用集合中的数，如果 S 中的整数不够 M 对，则取到不能取为止)，使得“每对数的差的平方”之和最大，这个最大值就称为集合 S 的“校验值”。</p>
<a id="more"></a>
<p>现在给定一个长度为 N 的数列 A 以及一个整数 T。</p>
<p>我们要把 A 分成若干段，使得每一段的“校验值”都不超过 T。</p>
<p>求最少需要分成几段。</p>
<h2 id="输入格式"><a class="markdownIt-Anchor" href="#输入格式"></a> 输入格式</h2>
<p>第一行输入整数 K，代表有 K 组测试数据。</p>
<p>对于每组测试数据，第一行包含三个整数 N,M,T 。</p>
<p>第二行包含 N 个整数，表示数列A1,A2…AN。</p>
<h2 id="输出格式"><a class="markdownIt-Anchor" href="#输出格式"></a> 输出格式</h2>
<p>对于每组测试数据，输出其答案，每个答案占一行。</p>
<h2 id="数据范围"><a class="markdownIt-Anchor" href="#数据范围"></a> 数据范围</h2>
<p>1≤K≤12,<br />
1≤N,M≤500000,<br />
0≤T≤10^18,<br />
0≤Ai≤2^20</p>
<h2 id="基本思路"><a class="markdownIt-Anchor" href="#基本思路"></a> 基本思路</h2>
<h3 id="朴素算法暴力"><a class="markdownIt-Anchor" href="#朴素算法暴力"></a> 朴素算法——暴力</h3>
<p>从这个集合的开头开始，确定每一个划分点。</p>
<p>采用类似贪心的方法，不考虑后面的数， 一个个向后枚举划分点。</p>
<p>拿样例数据举例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2</span><br><span class="line">5 1 49</span><br><span class="line">8 2 1 7 9</span><br><span class="line">5 1 64</span><br><span class="line">8 2 1 7 9</span><br></pre></td></tr></table></figure>
<p>先规定起始点 l 为 0，然后枚举：</p>
<p>{8} -&gt; {8, 2} -&gt; {8, 2, 1} -&gt; {8, 2, 1, 7} -&gt; {8, 2, 1, 7, 9} -&gt;{8, 2, 1, 7}, {9}</p>
<p>每次枚举还需要 O(n lg n) 的时间来排序，时间复杂度为 O(n^2 lg n)</p>
<h3 id="倍增其实有点像二分"><a class="markdownIt-Anchor" href="#倍增其实有点像二分"></a> 倍增（其实有点像二分）</h3>
<p>把枚举改成倍增</p>
<p>显而易见，对于相同的左端 l，右端 r 越大，校验值越大（也有可能相等）。</p>
<p>所以，校验值可以看成是具有单调性的，可以通过倍增求解。</p>
<p>具体来说，可以确定一个右端 R 和右端增加长度 p，如果这个序列的校验值小于等于上限，那么将 p 乘以 2，并且将右端更新（R+=p），如果大于上限，就将 p 除以 2。</p>
<p>这样，我们可以将时间复杂度降低到 O(n^2)</p>
<h3 id="关于排序"><a class="markdownIt-Anchor" href="#关于排序"></a> 关于排序</h3>
<p>每次求校验值时都需要排序，其实没有必要使用快速排序，可以采用归并排序，把新增的序列排好序然后再归并。时间复杂度 O(n lg n)</p>
<p>然而我用了时间复杂度相同的二分插入排序，但是后面 TLE 了，时间限制是10s，我的程序运行了600s</p>
<p><img src="https://i.loli.net/2020/07/26/FcR4CDdLo2WpeBJ.jpg" alt="Screenshot_20200726_132705.jpg" /></p>
<p>应该是 vector 常数太大了吧</p>
<h1 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h1>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">vector</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">min</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX=<span class="number">500005</span>;</span><br><span class="line"><span class="keyword">int</span> k, n, m;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt; o, ne;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> t, a[MAX];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">genius</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span>, <span class="keyword">int</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	freopen(<span class="string">"data.in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;k);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;k; i++)&#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d%d%lld"</span>, &amp;n, &amp;m, &amp;t);</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i++)&#123;</span><br><span class="line">			<span class="built_in">scanf</span>(<span class="string">"%lld"</span>, &amp;a[i]);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%d\n"</span>, genius());</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">genius</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> r=<span class="number">0</span>, ans=<span class="number">0</span>, l, p;</span><br><span class="line">	<span class="keyword">long</span> <span class="keyword">long</span> ch;</span><br><span class="line">	<span class="keyword">while</span>(r&lt;n)&#123;</span><br><span class="line">		<span class="keyword">if</span>(r==n<span class="number">-1</span>)&#123;</span><br><span class="line">			ans++; <span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		l=r; p=<span class="number">1</span>;</span><br><span class="line">		ne.<span class="built_in">clear</span>(); o.<span class="built_in">clear</span>();</span><br><span class="line">		<span class="keyword">while</span>(p!=<span class="number">0</span> &amp;&amp; r&lt;n)&#123;</span><br><span class="line">			ch = check(r, p);</span><br><span class="line">			<span class="keyword">if</span>(ch&lt;=t)&#123;</span><br><span class="line">				r+=p; p*=<span class="number">2</span>;</span><br><span class="line">				o=ne;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> p/=<span class="number">2</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		ans++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> r, <span class="keyword">int</span> p)</span></span>&#123;</span><br><span class="line">	ne=o;</span><br><span class="line">	<span class="keyword">int</span> l, r1, mid;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=r; i&lt;<span class="built_in">min</span>(r+p, n); i++)&#123;</span><br><span class="line">		l=<span class="number">0</span>; r1=ne.<span class="built_in">size</span>();</span><br><span class="line">		<span class="keyword">while</span>(l&lt;r1)&#123;</span><br><span class="line">			mid=(l+r1)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">			<span class="keyword">if</span>(ne[mid]&gt;=a[i]) r1=mid; </span><br><span class="line">			<span class="keyword">else</span> l=mid+<span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		ne.insert(ne.<span class="built_in">begin</span>()+l, a[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> s=ne.<span class="built_in">size</span>();</span><br><span class="line">	<span class="keyword">long</span> <span class="keyword">long</span> ans=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;m; i++)&#123;</span><br><span class="line">		<span class="keyword">if</span>(s&gt;=(i+<span class="number">1</span>)*<span class="number">2</span>)&#123;</span><br><span class="line">			ans+=(ne[i]-ne[s-i<span class="number">-1</span>])*(ne[i]-ne[s-i<span class="number">-1</span>]);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>题解</tag>
      </tags>
  </entry>
  <entry>
    <title>「XSection立体几何」游戏简介、平面、截面</title>
    <url>/2020/08/01/%E3%80%8CXSection%E7%AB%8B%E4%BD%93%E5%87%A0%E4%BD%95%E3%80%8D%E6%B8%B8%E6%88%8F%E7%AE%80%E4%BB%8B%E3%80%81%E5%B9%B3%E9%9D%A2%E3%80%81%E6%88%AA%E9%9D%A2/</url>
    <content><![CDATA[<h1 id="horis-international-limited-制作组"><a class="markdownIt-Anchor" href="#horis-international-limited-制作组"></a> Horis International Limited 制作组</h1>
<p>最近在玩 Euclidea 的时候，偶然发现，这个制作组在 Google Play 上还有其他的作品：</p>
<p><img src="https://s1.ax1x.com/2020/08/01/a3DC9A.jpg" alt="a3DC9A.jpg" /></p>
<p>玩了一圈下来，只有 Euclidea 中的题需要最优解，其他三个都不需要。在这些游戏中，我认为最有意思的是最后一个：XSection。</p>
<a id="more"></a>
<h1 id="关于xsection"><a class="markdownIt-Anchor" href="#关于xsection"></a> 关于XSection</h1>
<p>游戏共有11个章节，121个关卡。每个关卡都是关于立体几何的一道题，需要作图完成。</p>
<p><img src="https://s1.ax1x.com/2020/08/01/a3rFPJ.jpg" alt="a3rFPJ.jpg" /></p>
<p>值得注意的是，在整个游戏过程中，你只能进行两种操作：</p>
<ol>
<li>作过两个点的一条直线（连接两个点）</li>
<li>过一点作一条直线/线段的平行线</li>
</ol>
<p>这两种操作的存在，使一些问题的解决非常困难。但这两种最基本的操作，是可以解决这里面的所有问题的。</p>
<p>并且，在游戏中，你无法切换视图，只能以设定好的位置观察这个图形，放大或者缩小。</p>
<p>这个游戏并不要求最优解，也就是说，可以尽情放飞自我作图，只要有解法就可以过关。后面的关卡会难一些，需要比较强的空间想象力，并且后面的题需要等待4小时解锁，或者可以通过内购解锁所有关卡。</p>
<p>当然是有破解的方法的，我的经验告诉我，可以通过调系统时间来让软件误以为时间已经过去，测试之后果然有效。</p>
<p>据我所知，这个游戏国内的大部分应用商店都没有，可以在 Google Play 下载，国内的某些论坛/贴吧貌似也有安装包。</p>
<p>另外，这软件到目前（2020年8月1日）为止，是没有汉化的（只有 English 和 Russian）。某些关卡对于别人是数学题，对于我就是英译汉。但其实术语就那么多，那些看不懂的词还可以查自带的术语表（这个真的良心），所以对英语的要求并不高。</p>
<h1 id="立体图形的截面"><a class="markdownIt-Anchor" href="#立体图形的截面"></a> 立体图形的截面</h1>
<h2 id="平面"><a class="markdownIt-Anchor" href="#平面"></a> 平面</h2>
<p>先上  Wikipedia 对平面的定义</p>
<blockquote>
<p>数学上，一个平面（plane）就是基本的二维对象。直观的讲，它可以视为一个平坦的拥有无穷大面积的纸。多数几何、三角学和制图的基本工作都在二维进行，或者说，在平面上进行。</p>
</blockquote>
<p>众所周知，三个点可以定义一个平面，两点可以定义一条直线。</p>
<p>那么，四个点定义的两条不平行的直线，并不一定会相交，因为这四个点不一定处在同一个平面上。</p>
<p>所以，尽管不能切换视图，但某些看起来相交却无法作出交点的线时刻提醒着你正处在一个三维的世界中。</p>
<p>平面几何就是在一个平面上展开的。根据长期以来的经验，显然，一个平面上任意个点都是处在同一平面的，可以相交（或平行）。并且，这个平面上任意三个点都可以确定这个平面。</p>
<p>为什么要强调这个呢？因为这个游戏中许多解法的证明都是与这个有关的。</p>
<h2 id="截面"><a class="markdownIt-Anchor" href="#截面"></a> 截面</h2>
<p>游戏中大部分的问题是和立体图形的截面有关的。下面是 Wikipedia 对截面的定义：</p>
<blockquote>
<p>截面（英语：Cross section）为一几何学名词，是指一三维空间下的物体和一平面相交所产生交集。截面的面积称为截面积。</p>
</blockquote>
<p>截面，顾名思义，它是一个面。这个面是有限的，也就是说它存在面积。它是一个平面落在物体上的一个部分。</p>
<p>举个栗子：</p>
<p><img src="https://s1.ax1x.com/2020/08/01/a8BLsP.jpg" alt="a8BLsP.jpg" /></p>
<p>图中的六边形 JLKMNI 就是淡蓝色平面和正方体所产生的截面。可以将它想象成这个蓝色的面将这个正方体切成了两块，截面就是切下去之后多出来的那个面。</p>
<p>插句题外话，这幅图使用 GeoGebra 画出来的，这是一个非常好用的数学软件，之后应该会出一个关于它的介绍。我会把我所有的演示文件放到 <a href="https://www.geogebra.org/u/djl" target="_blank" rel="noopener">我的GeoGebra主页</a> 上了，不需要下载软件，直接在网页里就可以看。</p>
<p>To be continued……</p>
]]></content>
      <tags>
        <tag>XSection</tag>
        <tag>几何 - 立体几何</tag>
      </tags>
  </entry>
  <entry>
    <title>「USACO06FEB」Stall Reservations</title>
    <url>/2020/08/02/%E3%80%8CUSACO06FEB%E3%80%8DStall%20Reservations/</url>
    <content><![CDATA[<h1 id="题目链接-题面"><a class="markdownIt-Anchor" href="#题目链接-题面"></a> 题目链接 &amp; 题面</h1>
<p>貌似是 USACO 原创，但我实在找不到原创的链接，只能在洛谷、 AcWing 和 POJ 上找了</p>
<p>洛谷：<a href="https://www.luogu.com.cn/problem/P2859" target="_blank" rel="noopener">https://www.luogu.com.cn/problem/P2859</a></p>
<p>AcWing：<a href="https://www.acwing.com/problem/content/113/" target="_blank" rel="noopener">https://www.acwing.com/problem/content/113/</a></p>
<a id="more"></a>
<h2 id="题目描述"><a class="markdownIt-Anchor" href="#题目描述"></a> 题目描述</h2>
<p>有N头牛在畜栏中吃草。</p>
<p>每个畜栏在同一时间段只能提供给一头牛吃草，所以可能会需要多个畜栏。</p>
<p>给定N头牛和每头牛开始吃草的时间A以及结束吃草的时间B，每头牛在[A,B]这一时间段内都会一直吃草。</p>
<p>当两头牛的吃草区间存在交集时（包括端点），这两头牛不能被安排在同一个畜栏吃草。</p>
<p>求需要的最小畜栏数目和每头牛对应的畜栏方案。</p>
<h2 id="输入格式"><a class="markdownIt-Anchor" href="#输入格式"></a> 输入格式</h2>
<p>第1行：输入一个整数N。</p>
<p>第2…N+1行：第i+1行输入第i头牛的开始吃草时间A以及结束吃草时间B，数之间用空格隔开。</p>
<h2 id="输出格式"><a class="markdownIt-Anchor" href="#输出格式"></a> 输出格式</h2>
<p>第1行：输入一个整数，代表所需最小畜栏数。</p>
<p>第2…N+1行：第i+1行输入第i头牛被安排到的畜栏编号，编号是从1开始的 连续 整数，只要方案合法即可。</p>
<p>（洛谷上题目描述是挤奶，AcWing上是吃草。。。）</p>
<h1 id="基本算法"><a class="markdownIt-Anchor" href="#基本算法"></a> 基本算法</h1>
<h2 id="贪心"><a class="markdownIt-Anchor" href="#贪心"></a> 贪心</h2>
<p>应该是比较显而易见的一个贪心，我刚开始都不觉得自己有多贪。。</p>
<p>按开始的时间把牛排序，然后依次放入畜栏，每次尽量放在已经使用过的畜栏中，如果没有就新建一个畜栏，cnt++。</p>
<p>由于可以放进任意一个畜栏，可以直接选出结束时间最早的畜栏比较，如果比当前时间早就可以放入，如果比当前时间晚就新建。</p>
<p>因此，可以通过 <code>std::priority_queue</code> 来维护一个小根堆来存放畜栏使用情况（当然手写也可以</p>
<h2 id="priority_queue"><a class="markdownIt-Anchor" href="#priority_queue"></a> priority_queue</h2>
<p>我一般管这个叫优先队列，它可以保证队头的元素是 最小/最大 的。</p>
<p>对于这道题，存放畜栏的优先队列需要存放 畜栏中牛结束的时间 和 畜栏的编号，其中需要将最小值放在队首的是结束时间。因此，可以使用 <code>std::pair</code> 来作为一个单位存放。对于 pair ，每个元素进行比较时，先比较 first ，所以可以把结束时间放在 first 中。</p>
<p>当然，手写一个node然后重载运算符来自定义比较也可以，但这就是 C++ 的进阶操作了。</p>
<p>另外，在写的时候，一定要搞清楚队列里要存什么，思路一定要清晰（我就是因为这个被绕住了）</p>
<h1 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h1>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::priority_queue;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">vector</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::sort;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::greater;</span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">std</span>::pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; pint;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX=<span class="number">50005</span>;</span><br><span class="line"><span class="keyword">int</span> n, cnt, le, ans[MAX];</span><br><span class="line">priority_queue &lt; pint, <span class="built_in">vector</span>&lt;pint&gt;, greater&lt;pint&gt; &gt; cl;</span><br><span class="line">pint tmp;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Cow</span>&#123;</span></span><br><span class="line">	<span class="keyword">int</span> start, <span class="built_in">end</span>, nu;</span><br><span class="line">&#125;cow[MAX];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(Cow x, Cow y)</span> </span>&#123; <span class="keyword">return</span> x.start &lt; y.start; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	freopen(<span class="string">"data.in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line">	freopen(<span class="string">"data.out"</span>, <span class="string">"w"</span>, <span class="built_in">stdout</span>);</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i++)&#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d %d"</span>, &amp;cow[i].start, &amp;cow[i].<span class="built_in">end</span>);</span><br><span class="line">		cow[i].nu=i;</span><br><span class="line">	&#125;</span><br><span class="line">	sort(cow, cow+n, cmp);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i++)&#123;</span><br><span class="line">		<span class="keyword">if</span>(!cl.empty() &amp;&amp; cl.top().first&lt;cow[i].start)&#123;</span><br><span class="line">			ans[cow[i].nu]=cl.top().second;</span><br><span class="line">			cl.pop();</span><br><span class="line">			tmp.first=cow[i].<span class="built_in">end</span>; <span class="comment">// tmp.second=cl.size();</span></span><br><span class="line">			tmp.second=ans[cow[i].nu];</span><br><span class="line">			cl.push(tmp);</span><br><span class="line">			</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span>&#123;</span><br><span class="line">			cnt++;</span><br><span class="line">			tmp.first=cow[i].<span class="built_in">end</span>; tmp.second=cnt;</span><br><span class="line">			cl.push(tmp);</span><br><span class="line">			ans[cow[i].nu]=cnt;</span><br><span class="line">		&#125; </span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%d\n"</span>, cnt);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i++) <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans[i]);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>算法</tag>
        <tag>题解 - 贪心</tag>
      </tags>
  </entry>
</search>
